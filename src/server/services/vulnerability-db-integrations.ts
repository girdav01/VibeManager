/**
 * Integration with major vulnerability databases:
 * - MITRE CVE (https://cve.mitre.org)
 * - NVD (National Vulnerability Database) (https://nvd.nist.gov)
 * - OSV (Open Source Vulnerabilities) (https://osv.dev)
 * - GitHub Advisory Database (https://github.com/advisories)
 * - Snyk Vulnerability DB (https://snyk.io/vuln)
 */

interface CVEDetails {
  cveId: string;
  description: string;
  severity: string;
  cvssScore: number;
  publishedDate: string;
  affectedVersions: string[];
  fixedVersions: string[];
  references: string[];
}

interface VulnerabilityQueryResult {
  found: boolean;
  cveDetails?: CVEDetails;
  source: string;
}

class VulnerabilityDatabaseIntegrations {
  private osvApiUrl = "https://api.osv.dev/v1";
  private nvdApiUrl = "https://services.nvd.nist.gov/rest/json/cves/2.0";
  private githubApiUrl = "https://api.github.com/advisories";

  /**
   * Query OSV (Open Source Vulnerabilities) Database
   * OSV aggregates vulnerabilities from multiple sources including:
   * - npm, PyPI, RubyGems, Go, Maven, NuGet
   * - GitHub Security Advisories
   * - Python Software Foundation
   */
  async queryOSV(
    packageName: string,
    version: string,
    ecosystem: string
  ): Promise<VulnerabilityQueryResult[]> {
    try {
      const response = await fetch(`${this.osvApiUrl}/query`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          package: {
            name: packageName,
            ecosystem: this.mapEcosystem(ecosystem),
          },
          version,
        }),
      });

      if (!response.ok) {
        console.error("OSV API error:", response.statusText);
        return [];
      }

      const data = await response.json();

      if (!data.vulns || data.vulns.length === 0) {
        return [{ found: false, source: "OSV" }];
      }

      return data.vulns.map((vuln: any) => ({
        found: true,
        source: "OSV",
        cveDetails: {
          cveId: vuln.id,
          description: vuln.summary || vuln.details || "No description available",
          severity: this.mapSeverity(vuln.severity),
          cvssScore: this.extractCVSS(vuln),
          publishedDate: vuln.published || new Date().toISOString(),
          affectedVersions: this.extractAffectedVersions(vuln),
          fixedVersions: this.extractFixedVersions(vuln),
          references: vuln.references?.map((r: any) => r.url) || [],
        },
      }));
    } catch (error) {
      console.error("Error querying OSV:", error);
      return [];
    }
  }

  /**
   * Query NVD (National Vulnerability Database)
   * Maintained by NIST, authoritative source for CVE information
   */
  async queryNVD(cveId: string): Promise<VulnerabilityQueryResult | null> {
    try {
      // Note: NVD API requires API key for higher rate limits
      // Add ?apiKey=YOUR_KEY if you have one
      const response = await fetch(
        `${this.nvdApiUrl}?cveId=${encodeURIComponent(cveId)}`
      );

      if (!response.ok) {
        console.error("NVD API error:", response.statusText);
        return null;
      }

      const data = await response.json();

      if (
        !data.vulnerabilities ||
        data.vulnerabilities.length === 0 ||
        !data.vulnerabilities[0].cve
      ) {
        return { found: false, source: "NVD" };
      }

      const cve = data.vulnerabilities[0].cve;

      return {
        found: true,
        source: "NVD",
        cveDetails: {
          cveId: cve.id,
          description:
            cve.descriptions?.find((d: any) => d.lang === "en")?.value ||
            "No description",
          severity: this.extractNVDSeverity(cve),
          cvssScore: this.extractNVDCVSS(cve),
          publishedDate: cve.published,
          affectedVersions: this.extractNVDAffectedVersions(cve),
          fixedVersions: [],
          references: cve.references?.map((r: any) => r.url) || [],
        },
      };
    } catch (error) {
      console.error("Error querying NVD:", error);
      return null;
    }
  }

  /**
   * Query GitHub Advisory Database
   * GitHub's curated security advisories for npm, pip, rubygems, etc.
   */
  async queryGitHubAdvisory(
    packageName: string,
    ecosystem: string
  ): Promise<VulnerabilityQueryResult[]> {
    try {
      // GitHub GraphQL API would be more efficient, but REST works too
      const ecosystemParam = this.mapGitHubEcosystem(ecosystem);
      const response = await fetch(
        `${this.githubApiUrl}?ecosystem=${ecosystemParam}&affects=${encodeURIComponent(packageName)}`,
        {
          headers: {
            Accept: "application/vnd.github+json",
            "X-GitHub-Api-Version": "2022-11-28",
          },
        }
      );

      if (!response.ok) {
        console.error("GitHub Advisory API error:", response.statusText);
        return [];
      }

      const advisories = await response.json();

      if (!advisories || advisories.length === 0) {
        return [{ found: false, source: "GitHub Advisory" }];
      }

      return advisories.map((advisory: any) => ({
        found: true,
        source: "GitHub Advisory",
        cveDetails: {
          cveId: advisory.cve_id || advisory.ghsa_id,
          description: advisory.summary || advisory.description,
          severity: advisory.severity.toLowerCase(),
          cvssScore: advisory.cvss?.score || 0,
          publishedDate: advisory.published_at,
          affectedVersions: advisory.vulnerabilities?.map(
            (v: any) => v.package.ecosystem + ":" + v.vulnerable_version_range
          ) || [],
          fixedVersions: advisory.vulnerabilities?.map(
            (v: any) => v.first_patched_version?.identifier
          ).filter(Boolean) || [],
          references: [advisory.html_url],
        },
      }));
    } catch (error) {
      console.error("Error querying GitHub Advisory:", error);
      return [];
    }
  }

  /**
   * Query multiple sources and aggregate results
   */
  async queryAllSources(
    packageName: string,
    version: string,
    ecosystem: string
  ): Promise<VulnerabilityQueryResult[]> {
    const results: VulnerabilityQueryResult[] = [];

    // Query OSV (includes data from multiple sources)
    const osvResults = await this.queryOSV(packageName, version, ecosystem);
    results.push(...osvResults);

    // Query GitHub Advisory
    const ghResults = await this.queryGitHubAdvisory(packageName, ecosystem);
    results.push(...ghResults);

    // If CVE IDs found, query NVD for authoritative details
    const cveIds = results
      .filter((r) => r.found && r.cveDetails?.cveId?.startsWith("CVE-"))
      .map((r) => r.cveDetails!.cveId);

    for (const cveId of cveIds) {
      const nvdResult = await this.queryNVD(cveId);
      if (nvdResult) {
        results.push(nvdResult);
      }
    }

    // Deduplicate by CVE ID
    const seen = new Set<string>();
    return results.filter((result) => {
      if (!result.found || !result.cveDetails) return true;
      if (seen.has(result.cveDetails.cveId)) return false;
      seen.add(result.cveDetails.cveId);
      return true;
    });
  }

  /**
   * Get latest CVEs from MITRE
   * Note: MITRE doesn't have a public API, but CVE data is available via NVD
   */
  async getLatestCVEs(limit: number = 20): Promise<CVEDetails[]> {
    try {
      // Get recent CVEs from NVD (which includes MITRE CVE data)
      const response = await fetch(
        `${this.nvdApiUrl}?resultsPerPage=${limit}&startIndex=0`
      );

      if (!response.ok) {
        console.error("Error fetching latest CVEs:", response.statusText);
        return [];
      }

      const data = await response.json();

      if (!data.vulnerabilities) return [];

      return data.vulnerabilities.map((item: any) => {
        const cve = item.cve;
        return {
          cveId: cve.id,
          description:
            cve.descriptions?.find((d: any) => d.lang === "en")?.value || "",
          severity: this.extractNVDSeverity(cve),
          cvssScore: this.extractNVDCVSS(cve),
          publishedDate: cve.published,
          affectedVersions: [],
          fixedVersions: [],
          references: cve.references?.map((r: any) => r.url) || [],
        };
      });
    } catch (error) {
      console.error("Error fetching latest CVEs:", error);
      return [];
    }
  }

  // Helper methods

  private mapEcosystem(ecosystem: string): string {
    const mapping: { [key: string]: string } = {
      npm: "npm",
      pip: "PyPI",
      bundler: "RubyGems",
      composer: "Packagist",
      maven: "Maven",
      nuget: "NuGet",
      go: "Go",
    };
    return mapping[ecosystem] || ecosystem;
  }

  private mapGitHubEcosystem(ecosystem: string): string {
    const mapping: { [key: string]: string } = {
      npm: "npm",
      pip: "pip",
      bundler: "rubygems",
      composer: "composer",
      maven: "maven",
      nuget: "nuget",
    };
    return mapping[ecosystem] || ecosystem;
  }

  private mapSeverity(severity: any): string {
    if (typeof severity === "string") return severity;
    if (Array.isArray(severity)) {
      return severity[0]?.type || "UNKNOWN";
    }
    return "UNKNOWN";
  }

  private extractCVSS(vuln: any): number {
    if (vuln.severity) {
      for (const sev of vuln.severity) {
        if (sev.score) return parseFloat(sev.score);
      }
    }
    return 0;
  }

  private extractNVDSeverity(cve: any): string {
    const metrics = cve.metrics;
    if (metrics?.cvssMetricV31?.[0]?.cvssData?.baseSeverity) {
      return metrics.cvssMetricV31[0].cvssData.baseSeverity;
    }
    if (metrics?.cvssMetricV2?.[0]?.baseSeverity) {
      return metrics.cvssMetricV2[0].baseSeverity;
    }
    return "UNKNOWN";
  }

  private extractNVDCVSS(cve: any): number {
    const metrics = cve.metrics;
    if (metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore) {
      return metrics.cvssMetricV31[0].cvssData.baseScore;
    }
    if (metrics?.cvssMetricV2?.[0]?.cvssData?.baseScore) {
      return metrics.cvssMetricV2[0].cvssData.baseScore;
    }
    return 0;
  }

  private extractAffectedVersions(vuln: any): string[] {
    if (!vuln.affected) return [];
    return vuln.affected.flatMap((a: any) =>
      a.ranges?.map((r: any) => r.events?.map((e: any) => e.introduced).filter(Boolean)).flat() || []
    );
  }

  private extractFixedVersions(vuln: any): string[] {
    if (!vuln.affected) return [];
    return vuln.affected.flatMap((a: any) =>
      a.ranges?.map((r: any) => r.events?.map((e: any) => e.fixed).filter(Boolean)).flat() || []
    );
  }

  private extractNVDAffectedVersions(cve: any): string[] {
    // NVD structure is complex, simplified extraction
    return [];
  }
}

export const vulnerabilityDB = new VulnerabilityDatabaseIntegrations();
